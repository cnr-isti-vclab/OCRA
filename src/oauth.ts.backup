/**
 * Minimal OAuth2 Authorization Code Flow with PKCE for the browser.
 * Now integrated with database storage instead of sessionStorage for tokens.
 *
 * This module intentionally uses small, readable functions and inline comments
 * so it can be used in a course to explain the moving parts.
 * 
 * DATABASE INTEGRATION:
 * Instead of storing tokens directly in sessionStorage (which is insecure for production),
 * we now store them in a database and only keep a session ID in sessionStorage.
 * This provides better security and allows for server-side session management.
 */

import { 
  createUserSession, 
  getValidSession, 
  deleteSession, 
  logLoginEvent,
  logLogoutEvent,
  getUserLoginHistory,
} from './db-browser'; // Use browser-compatible simulation

import type { OAuthTokens, UserProfile } from './types';

export type OAuthConfig = {
  issuer: string; // e.g. https://localhost:8081/realms/demo (for Keycloak)
  realm?: string; // optional, informational
  clientId: string; // public SPA client
  redirectUri: string; // where the provider should redirect back to
  scope?: string; // e.g. "openid profile email"
};

type DiscoveryDoc = {
  authorization_endpoint: string;
  token_endpoint: string;
  userinfo_endpoint: string;
  end_session_endpoint?: string; // Keycloak exposes logout at a well-known path even if not in discovery
};

// Keys used in sessionStorage. Now only stores session ID instead of full tokens.
const SS = {
  verifier: 'oauth_pkce_verifier',
  state: 'oauth_state',
  sessionId: 'oauth_session_id', // Changed: only store session ID, not full tokens
  discovery: 'oauth_discovery',
} as const;

// Read runtime configuration from window.__APP_CONFIG__ (injected at container start)
// and fall back to Vite env for local dev (VITE_* variables).
export function getConfig(): OAuthConfig {
  const w = window as any;
  const runtime = w.__APP_CONFIG__ || {};
  const issuer = runtime.issuer || runtime.providerUrl && runtime.realm ? `${runtime.providerUrl.replace(/\/$/, '')}/realms/${runtime.realm}` : undefined;
  const envIssuer = import.meta?.env?.VITE_ISSUER as string | undefined;
  const envProvider = import.meta?.env?.VITE_PROVIDER_URL as string | undefined;
  const envRealm = import.meta?.env?.VITE_REALM as string | undefined;
  const issuerFromEnv = envIssuer || (envProvider && envRealm ? `${envProvider.replace(/\/$/, '')}/realms/${envRealm}` : undefined);

  const cfg: OAuthConfig = {
    issuer: issuer || issuerFromEnv || 'http://localhost:8081/realms/demo',
    realm: runtime.realm || envRealm,
    clientId: runtime.clientId || (import.meta?.env?.VITE_CLIENT_ID as string) || 'react-oauth',
    redirectUri: runtime.redirectUri || (import.meta?.env?.VITE_REDIRECT_URI as string) || window.location.origin,
    scope: runtime.scope || (import.meta?.env?.VITE_SCOPE as string) || 'openid profile email',
  };
  return cfg;
}

// OpenID Connect discovery to find endpoints.
async function discoverEndpoints(issuer: string): Promise<DiscoveryDoc> {
  const cached = sessionStorage.getItem(SS.discovery);
  if (cached) return JSON.parse(cached) as DiscoveryDoc;

  const res = await fetch(`${issuer.replace(/\/$/, '')}/.well-known/openid-configuration`);
  if (!res.ok) throw new Error(`Failed discovery: ${res.status}`);
  const json = await res.json();
  const doc: DiscoveryDoc = {
    authorization_endpoint: json.authorization_endpoint,
    token_endpoint: json.token_endpoint,
    userinfo_endpoint: json.userinfo_endpoint,
    end_session_endpoint: json.end_session_endpoint,
  };
  sessionStorage.setItem(SS.discovery, JSON.stringify(doc));
  return doc;
}

// PKCE helpers: generate a random code verifier and its SHA-256 based challenge.
function base64UrlEncode(buf: ArrayBuffer): string {
  const bytes = new Uint8Array(buf);
  let str = '';
  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
}

function randomString(bytes = 32): string {
  const arr = new Uint8Array(bytes);
  crypto.getRandomValues(arr);
  return base64UrlEncode(arr.buffer);
}

async function sha256(input: string): Promise<ArrayBuffer> {
  const enc = new TextEncoder();
  const data = enc.encode(input);
  return crypto.subtle.digest('SHA-256', data);
}

async function pkceChallengeFromVerifier(verifier: string): Promise<string> {
  const digest = await sha256(verifier);
  return base64UrlEncode(digest);
}

// 1) Starts the Authorization Code flow: we build an authorization URL and redirect the browser.
export async function loginWithRedirect(): Promise<never> {
  const cfg = getConfig();
  const discovery = await discoverEndpoints(cfg.issuer);

  const verifier = randomString(64);
  const challenge = await pkceChallengeFromVerifier(verifier);
  const state = randomString(32);
  sessionStorage.setItem(SS.verifier, verifier);
  sessionStorage.setItem(SS.state, state);

  const authUrl = new URL(discovery.authorization_endpoint);
  authUrl.searchParams.set('client_id', cfg.clientId);
  authUrl.searchParams.set('redirect_uri', cfg.redirectUri);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('scope', cfg.scope || 'openid profile email');
  authUrl.searchParams.set('state', state);
  authUrl.searchParams.set('code_challenge', challenge);
  authUrl.searchParams.set('code_challenge_method', 'S256');

  // Redirecting away from the SPA to the provider login page.
  window.location.href = authUrl.toString();
  // Make TypeScript happy: this function never returns because we navigate.
  throw new Error('redirecting');
}

// 2) After the provider redirects back, we should have ?code=...&state=... in the URL.
export function isReturningFromAuth(loc: Location): boolean {
  const params = new URLSearchParams(loc.search);
  return params.has('code') && params.has('state');
}

// 3) Exchange the code for tokens using the PKCE code_verifier.
// Now also stores the session in database instead of sessionStorage.
export async function completeAuthCodeFlow(): Promise<{ sessionId: string; userProfile: UserProfile }> {
  const cfg = getConfig();
  const discovery = await discoverEndpoints(cfg.issuer);
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const state = params.get('state');
  const expectedState = sessionStorage.getItem(SS.state);
  const verifier = sessionStorage.getItem(SS.verifier);
  
  if (!code || !state) throw new Error('Missing authorization code or state');
  if (!verifier) throw new Error('Missing PKCE verifier in session');
  if (!expectedState || expectedState !== state) throw new Error('State mismatch');

  // Exchange authorization code for tokens
  const body = new URLSearchParams();
  body.set('grant_type', 'authorization_code');
  body.set('code', code);
  body.set('redirect_uri', cfg.redirectUri);
  body.set('client_id', cfg.clientId);
  body.set('code_verifier', verifier);

  const res = await fetch(discovery.token_endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body,
  });
  if (!res.ok) throw new Error(`Token exchange failed: ${res.status}`);
  const tokens = (await res.json()) as OAuthTokens;

  // Get user profile information
  const userProfile = await getUserProfileFromToken(tokens.access_token);
  
  try {
    // Store session in database
    const sessionId = await createUserSession(userProfile, tokens);
    
    // Store only session ID in sessionStorage (not the full tokens)
    sessionStorage.setItem(SS.sessionId, sessionId);
    
    // Clean up PKCE temporary data
    sessionStorage.removeItem(SS.state);
    sessionStorage.removeItem(SS.verifier);
    
    // Log successful login for audit
    await logLoginEvent(
      userProfile.sub, 
      true, 
      navigator.userAgent,
      // Note: Getting real IP requires server-side logging
      'client-side',
      'login',
      sessionId
    );
    
    return { sessionId, userProfile };
  } catch (error) {
    // Log failed login attempt
    await logLoginEvent(
      userProfile.sub, 
      false, 
      navigator.userAgent, 
      'client-side',
      'login',
      undefined,
      error instanceof Error ? error.message : String(error)
    );
    throw new Error(`Failed to create session: ${error}`);
  }
}

// 4) Call the userinfo endpoint to get user profile information
async function getUserProfileFromToken(accessToken: string): Promise<UserProfile> {
  const cfg = getConfig();
  const discovery = await discoverEndpoints(cfg.issuer);
  const res = await fetch(discovery.userinfo_endpoint, {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  if (!res.ok) throw new Error(`userinfo failed: ${res.status}`);
  const userInfo = await res.json();
  
  return {
    sub: userInfo.sub,
    email: userInfo.email,
    name: userInfo.name || userInfo.preferred_username,
  };
}

// Get user information from current session
// This gets data from database instead of calling userinfo API repeatedly
export async function getCurrentUser(): Promise<{ name?: string; email?: string; sub: string } | null> {
  const sessionId = sessionStorage.getItem(SS.sessionId);
  if (!sessionId) return null;
  
  const session = await getValidSession(sessionId);
  if (!session) {
    // Session expired or invalid, clean up
    sessionStorage.removeItem(SS.sessionId);
    return null;
  }
  
  return {
    sub: session.user.sub,
    name: session.user.name || undefined,
    email: session.user.email,
  };
}

// Helper function to check if user is currently logged in
export async function isLoggedIn(): Promise<boolean> {
  const user = await getCurrentUser();
  return user !== null;
}

// Helper function to get access token for API calls (if needed)
export async function getAccessToken(): Promise<string | null> {
  const sessionId = sessionStorage.getItem(SS.sessionId);
  if (!sessionId) return null;
  
  const session = await getValidSession(sessionId);
  return session?.accessToken || null;
}

// Get current user's login/logout history for audit purposes
export async function getCurrentUserAuditLog(limit = 10) {
  const user = await getCurrentUser();
  if (!user) return [];
  
  return await getUserLoginHistory(user.sub, limit);
}

// 5) Logout: clear session from database and redirect to provider logout endpoint
export async function logout() {
  const cfg = getConfig();
  const sessionId = sessionStorage.getItem(SS.sessionId);
  
  // Get user info before cleanup for logging
  let userSub: string | undefined;
  if (sessionId) {
    try {
      const session = await getValidSession(sessionId);
      userSub = session?.user.sub;
    } catch (error) {
      console.error('Failed to get user info for logout logging:', error);
    }
  }
  
  // Clean up local session storage
  sessionStorage.removeItem(SS.sessionId);
  
  // Delete session from database and log logout event
  if (sessionId) {
    try {
      await deleteSession(sessionId);
      
      // Log successful logout event
      if (userSub) {
        await logLogoutEvent(
          userSub,
          sessionId,
          navigator.userAgent,
          'client-side'
        );
      }
    } catch (error) {
      console.error('Failed to delete session from database:', error);
      
      // Log failed logout event if we have user info
      if (userSub) {
        await logLoginEvent(
          userSub,
          false,
          navigator.userAgent,
          'client-side',
          'logout',
          sessionId,
          error instanceof Error ? error.message : String(error)
        );
      }
      
      // Continue with logout even if database cleanup fails
    }
  }

  // Redirect to provider logout endpoint for complete sign-out
  // Note: We can't get id_token anymore since we don't store it in sessionStorage
  // This is a security improvement, but means we lose the id_token_hint optimization
  const logoutUrl = new URL(`${cfg.issuer.replace(/\/$/, '')}/protocol/openid-connect/logout`);
  logoutUrl.searchParams.set('post_logout_redirect_uri', cfg.redirectUri);
  logoutUrl.searchParams.set('client_id', cfg.clientId);
  
  window.location.href = logoutUrl.toString();
}
